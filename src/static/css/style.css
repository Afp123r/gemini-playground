:root {
    /* Updated color palette for a softer, modern light theme */
    --primary-color: #4CAF50; /* A pleasant green for primary actions */
    --secondary-color: #2196F3; /* A vibrant blue for secondary actions */
    --danger-color: #F44336; /* Consistent red for danger/stop */
    --background-color: #F8F9FA; /* Light grey background */
    --surface-color: #FFFFFF; /* Pure white for card-like surfaces */
    --border-color: #E0E0E0; /* Lighter border for subtlety */
    --text-color: #333333; /* Darker text for readability */
    --text-secondary: #757575; /* Medium grey for secondary text */
    --shadow-color: rgba(0, 0, 0, 0.1); /* Subtle shadow */
    --border-radius-sm: 6px;
    --border-radius-md: 10px;
    --border-radius-lg: 12px;
    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
    --primary-color-rgb: 76, 175, 80; /* RGB for primary color */
}

body {
    font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    justify-content: center;
    align-items: flex-start; /* Align to top for better content flow */
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    background-color: var(--background-color);
    color: var(--text-color);
    padding: var(--spacing-lg); /* Add padding to body */
    box-sizing: border-box; /* Include padding in element's total width and height */
}

#app {
    background-color: var(--surface-color);
    border-radius: var(--border-radius-lg);
    padding: var(--spacing-lg);
    box-shadow: 0 6px 20px var(--shadow-color); /* Enhanced shadow */
    width: 90%; /* Slightly wider */
    max-width: 900px; /* Adjusted max-width */
    display: flex; /* Use flexbox for main app layout */
    flex-direction: column;
    gap: var(--spacing-md); /* Consistent spacing between sections */
}

/* Header Bar for API Key and Settings Toggle */
.header-bar {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
}

#api-key {
    flex-grow: 1;
    padding: 12px 15px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-md);
    background-color: #F5F5F5; /* Slightly off-white for input */
    color: var(--text-color);
    font-size: 1em;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

#api-key::placeholder {
    color: var(--text-secondary);
}

#api-key:focus {
    border-color: var(--primary-color);
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 0 3px rgba(var(--primary-color-rgb), 0.2);
    outline: none;
}

/* Config Toggle Button */
#config-toggle {
    background-color: var(--secondary-color);
    color: white;
    border: none;
    border-radius: var(--border-radius-md);
    padding: 12px;
    cursor: pointer;
    font-size: 1.2em;
    transition: background-color 0.3s ease, transform 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
}

#config-toggle:hover {
    background-color: #1976D2; /* Darker blue on hover */
    transform: translateY(-1px);
}

#config-toggle.active {
    background-color: var(--primary-color); /* Green when active */
    transform: rotate(90deg);
}

/* Configuration Container */
#config-container {
    background-color: #F0F0F0; /* Slightly darker surface for config */
    border-radius: var(--border-radius-md);
    padding: var(--spacing-lg);
    margin-bottom: var(--spacing-md);
    box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.4s ease-out;
    max-height: 0;
    overflow: hidden;
    opacity: 0;
    transform: translateY(-10px);
}

#config-container.active {
    max-height: 500px; /* Adjust based on content height */
    opacity: 1;
    transform: translateY(0);
}

.config-wrapper {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-md);
}

.setting-container {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    flex-wrap: wrap;
}

.setting-label {
    font-weight: bold;
    color: var(--text-secondary);
    min-width: 90px; /* Align labels */
}

select, textarea, input[type="number"] {
    flex-grow: 1;
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    background-color: #FBFBFB;
    color: var(--text-color);
    font-size: 0.95em;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    transition: border-color 0.3s ease;
    min-width: 150px;
}

select:focus, textarea:focus, input[type="number"]:focus {
    border-color: var(--primary-color);
    outline: none;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 0 3px rgba(var(--primary-color-rgb), 0.2);
}

textarea {
    resize: vertical;
    min-height: 100px; /* Slightly larger textarea */
}

input[type="number"] {
    width: 80px;
    text-align: center;
}

.fps-help {
    font-size: 0.85em;
    color: var(--text-secondary);
    margin-left: var(--spacing-sm);
}

#apply-config {
    background-color: var(--primary-color);
    color: white;
    padding: 12px 20px;
    border: none;
    border-radius: var(--border-radius-md);
    cursor: pointer;
    font-size: 1em;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease;
    box-shadow: 0 4px 10px rgba(var(--primary-color-rgb), 0.3);
    align-self: flex-end;
}

#apply-config:hover {
    background-color: #388E3C; /* Darker green on hover */
    transform: translateY(-2px);
}

/* Connect Button */
#connect-button {
    background-color: var(--secondary-color);
    color: white;
    padding: 15px 25px;
    border: none;
    border-radius: var(--border-radius-md);
    cursor: pointer;
    font-size: 1.1em;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    box-shadow: 0 4px 10px rgba(33, 150, 243, 0.3); /* Shadow for blue button */
    width: 100%;
}

#connect-button:hover {
    background-color: #1976D2;
    transform: translateY(-2px);
    box-shadow: 0 6px 15px rgba(33, 150, 243, 0.4);
}

#connect-button.connected {
    background-color: var(--danger-color);
    box-shadow: 0 4px 10px rgba(244, 67, 54, 0.3); /* Shadow for red button */
}

#connect-button.connected:hover {
    background-color: #D32F2F;
}

#connect-button:disabled {
    background-color: #B0B0B0; /* Lighter grey for disabled */
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
}

/* Log Container */
#logs-container {
    border: 1px solid var(--border-color);
    height: 300px;
    overflow-y: auto;
    padding: var(--spacing-md);
    border-radius: var(--border-radius-md);
    background: var(--surface-color); /* Consistent surface color */
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.05);
    scroll-behavior: smooth;
    display: flex; /* Flex for log entries */
    flex-direction: column;
    gap: var(--spacing-sm);
}

#logs-container:hover {
    box-shadow: 0 4px 15px var(--shadow-color);
}

.log-entry {
    display: flex;
    align-items: flex-start;
    gap: var(--spacing-sm);
    padding: var(--spacing-sm) var(--spacing-md);
    border-radius: var(--border-radius-sm);
    font-size: 0.95em;
    line-height: 1.5;
}

.log-entry.system {
    background-color: #E8F5E9; /* Light green */
    color: #388E3C; /* Dark green text */
}

.log-entry.user {
    background-color: #E3F2FD; /* Light blue */
    color: #1976D2; /* Dark blue text */
    align-self: flex-end; /* User messages align right */
    max-width: 80%;
}

.log-entry.ai {
    background-color: #FFEBEE; /* Light red */
    color: #D32F2F; /* Dark red text */
    align-self: flex-start; /* AI messages align left */
    max-width: 80%;
}

.log-entry .timestamp {
    font-size: 0.8em;
    color: var(--text-secondary);
    white-space: nowrap;
}

.log-entry .emoji {
    font-size: 1.1em;
    line-height: 1;
}

/* Input Controls (Message Input & Buttons) */
.input-controls {
    display: flex;
    gap: var(--spacing-sm);
    align-items: stretch;
    flex-wrap: wrap;
}

#message-input {
    flex-grow: 1;
    padding: 12px 15px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-md);
    background-color: #F5F5F5;
    color: var(--text-color);
    font-size: 1em;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08);
    min-width: 150px;
}

#message-input::placeholder {
    color: var(--text-secondary);
}

#message-input:focus {
    border-color: var(--secondary-color);
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1), 0 0 0 3px rgba(33, 150, 243, 0.2);
    outline: none;
}

#message-input:disabled {
    background-color: #E0E0E0;
    cursor: not-allowed;
    color: #B0B0B0;
}

.input-controls button {
    background-color: var(--secondary-color);
    color: white;
    border: none;
    border-radius: var(--border-radius-md);
    padding: 12px 15px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
    display: flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    position: relative;
    overflow: hidden; /* For ripple effect */
}

.input-controls button:hover {
    background-color: #1976D2;
    transform: translateY(-1px);
}

.input-controls button:disabled {
    background-color: #B0B0B0;
    cursor: not-allowed;
    box-shadow: none;
    transform: none;
}

/* Button Ripple Effect */
.input-controls button::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.3); /* Slightly more visible ripple */
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.3s ease-out, height 0.3s ease-out;
    pointer-events: none;
    opacity: 0; /* Start hidden */
}

.input-controls button:active::after {
    width: 200px;
    height: 200px;
    opacity: 1; /* Fade in on active */
    transition: width 0.0s, height 0.0s, opacity 0.3s ease-out; /* Instant size, then fade out */
}


#mic-button.active {
    background-color: var(--danger-color);
}
#mic-button.active:hover {
    background-color: #D32F2F;
}

#camera-button.active, #screen-button.active {
    background-color: var(--primary-color);
}
#camera-button.active:hover, #screen-button.active:hover {
    background-color: #388E3C;
}

/* Audio Visualizers */
.audio-visualizers {
    display: flex;
    gap: var(--spacing-md);
    margin-top: var(--spacing-md);
    flex-wrap: wrap;
    justify-content: space-around;
}

.visualizer-container {
    flex: 1;
    min-width: 280px; /* Slightly larger min-width */
    background-color: #F0F0F0;
    border-radius: var(--border-radius-md);
    padding: var(--spacing-md);
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08);
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
}

.visualizer-container label {
    font-weight: bold;
    color: var(--text-secondary);
    font-size: 0.9em;
}

#input-audio-visualizer, #audio-visualizer {
    width: 100%;
    height: 20px;
    background-color: #E0E0E0;
    border-radius: var(--border-radius-sm);
    overflow: hidden;
    position: relative;
    border: 1px solid var(--border-color);
}

#input-audio-visualizer .audio-bar {
    height: 100%;
    background-color: var(--primary-color); /* Green for input audio */
    width: 0%;
}

#audio-visualizer .audio-bar {
    height: 100%;
    background-color: var(--secondary-color); /* Blue for output audio */
    width: 0%;
}

/* Audio bar pulse animation */
@keyframes audio-pulse {
    0% { transform: scaleY(1); }
    50% { transform: scaleY(1.3); } /* Slightly less aggressive pulse */
    100% { transform: scaleY(1); }
}

.audio-bar.active {
    animation: audio-pulse 0.5s infinite alternate; /* Added alternate */
}

/* Video and Screen Containers - STRICTLY from your ORIGINAL CSS */
#video-container {
    position: fixed;
    bottom: 20px; /* Original value */
    right: 20px; /* Original value */
    width: 480px; /* Original value */
    z-index: 100; /* Original value */
}

#video-container video {
    width: 100%; /* Original value */
    border-radius: 8px; /* Original value */
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Original value */
}

.video-controls {
    position: absolute;
    top: 10px; /* Original value */
    right: 10px; /* Original value */
    z-index: 101; /* Original value */
    opacity: 0; /* Original value */
    transition: opacity 0.3s ease; /* Original value */
}

#video-container:hover .video-controls {
    opacity: 1; /* Original value */
}

#stop-video {
    background: #ea4335; /* Original value */
    color: white; /* Original value */
    border: none; /* Original value */
    padding: 8px 16px; /* Original value */
    border-radius: 4px; /* Original value */
    cursor: pointer; /* Original value */
    transition: background-color 0.3s ease; /* Original value */
}

#stop-video:hover {
    background: #d33426; /* Original value */
}

#flip-camera {
    border: none; /* Original value */
    padding: 8px 16px; /* Original value */
    border-radius: 4px; /* Original value */
    cursor: pointer; /* Original value */
    transition: background-color 0.3s ease; /* Original value */
}

#camera-button {
    background: #4285f4; /* Original value */
    color: white; /* Original value */
    border: none; /* Original value */
    padding: 8px; /* Original value */
    border-radius: 50%; /* Original value */
    cursor: pointer; /* Original value */
    margin-left: 8px; /* Original value */
    transition: all 0.2s ease; /* Original value */
    position: relative; /* Original value */
    overflow: hidden; /* Original value */
}

#camera-button:hover {
    transform: translateY(-2px); /* Original value */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Original value */
}

#camera-button:active {
    transform: translateY(1px); /* Original value */
}

#camera-button::after {
    content: ''; /* Original value */
    position: absolute; /* Original value */
    top: 50%; /* Original value */
    left: 50%; /* Original value */
    width: 0; /* Original value */
    height: 0; /* Original value */
    background: rgba(255, 255, 255, 0.2); /* Original value */
    border-radius: 50%; /* Original value */
    transform: translate(-50%, -50%); /* Original value */
    transition: width 0.3s ease, height 0.3s ease; /* Original value */
}

#camera-button:active::after {
    width: 200px; /* Original value */
    height: 200px; /* Original value */
}

#camera-button.active {
    background: #ea4335; /* Original value */
}

#frame-preview {
    position: absolute; /* Original value */
    bottom: 2px; /* Original value */
    right: 2px; /* Original value */
    width: 120px; /* Original value */
    height: 90px; /* Original value */
    border: 2px solid rgba(66, 133, 244, 0.8); /* Original value */
    border-radius: 4px; /* Original value */
    background: #000; /* Original value */
    z-index: 2; /* Original value */
    transition: all 0.3s ease; /* Original value */
    cursor: pointer; /* Original value */
}

#frame-preview:hover {
    transform: scale(1.1); /* Original value */
    border-color: #4285f4; /* Original value */
}

#frame-preview.enlarged {
    width: 480px; /* Original value */
    height: 360px; /* Original value */
    bottom: 50%; /* Original value */
    right: 50%; /* Original value */
    transform: translate(50%, 50%); /* Original value */
    z-index: 4; /* Original value */
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.5); /* Original value */
}

#frame-preview.enlarged::before {
    content: ''; /* Original value */
    position: fixed; /* Original value */
    top: 0; /* Original value */
    left: 0; /* Original value */
    right: 0; /* Original value */
    bottom: 0; /* Original value */
    background: rgba(0, 0, 0, 0.5); /* Original value */
    z-index: -1; /* Original value */
}

/* Improve video controls visibility */
.video-controls {
    opacity: 0; /* Original value */
    transition: opacity 0.3s ease; /* Original value */
}

#video-container:hover .video-controls {
    opacity: 1; /* Original value */
}

#screen-button {
    background: #4285f4; /* Original value */
    color: white; /* Original value */
    border: none; /* Original value */
    padding: 8px; /* Original value */
    border-radius: 50%; /* Original value */
    cursor: pointer; /* Original value */
    margin-left: 8px; /* Original value */
    transition: all 0.2s ease; /* Original value */
    position: relative; /* Original value */
    overflow: hidden; /* Original value */
}

#screen-button:hover {
    transform: translateY(-2px); /* Original value */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); /* Original value */
}

#screen-button:active {
    transform: translateY(1px); /* Original value */
}

#screen-button::after {
    content: ''; /* Original value */
    position: absolute; /* Original value */
    top: 50%; /* Original value */
    left: 50%; /* Original value */
    width: 0; /* Original value */
    height: 0; /* Original value */
    background: rgba(255, 255, 255, 0.2); /* Original value */
    border-radius: 50%; /* Original value */
    transform: translate(-50%, -50%); /* Original value */
    transition: width 0.3s ease, height 0.3s ease; /* Original value */
}

#screen-button:active::after {
    width: 200px; /* Original value */
    height: 200px; /* Original value */
}

#screen-button.active {
    background: #ea4335; /* Original value */
}

/* Add styles for screen preview */
#screen-container {
    position: fixed; /* Original value */
    top: 20px; /* Original value */
    right: 20px; /* Original value */
    background: #000; /* Original value */
    border-radius: 12px; /* Original value */
    overflow: hidden; /* Original value */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); /* Original value */
    width: 480px; /* Original value */
    height: 360px; /* Original value */
    transition: all 0.3s ease; /* Original value */
    display: none; /* Original value */
    z-index: 1000; /* Original value */
}

#screen-preview {
    width: 100%; /* Original value */
    height: 100%; /* Original value */
    object-fit: contain; /* Original value */
    background: #000; /* Original value */
    display: block; /* Original value */
}

/* Add hover effect */
#screen-container:hover {
    transform: scale(1.02); /* Original value */
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25); /* Original value */
}

/* Add a close button */
#screen-container .close-button {
    position: absolute; /* Original value */
    top: 10px; /* Original value */
    right: 10px; /* Original value */
    background: rgba(0, 0, 0, 0.5); /* Original value */
    color: white; /* Original value */
    border: none; /* Original value */
    border-radius: 50%; /* Original value */
    width: 30px; /* Original value */
    height: 30px; /* Original value */
    cursor: pointer; /* Original value */
    display: flex; /* Original value */
    align-items: center; /* Original value */
    justify-content: center; /* Original value */
    opacity: 0; /* Original value */
    transition: opacity 0.3s ease; /* Original value */
}

#screen-container:hover .close-button {
    opacity: 1; /* Original value */
}

#screen-container .close-button:hover {
    background: rgba(0, 0, 0, 0.8); /* Original value */
}

.audio-visualizers {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin: 10px 0;
}

.visualizer-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.visualizer-container label {
    font-size: 0.8em;
    color: #666;
}

#input-audio-visualizer,
#audio-visualizer {
    width: 100%;
    height: 20px;
    background-color: #eee;
    border-radius: 4px;
    overflow: hidden;
}

#input-audio-visualizer .audio-bar {
    height: 100%;
    background-color: #34a853; /* Green for input audio */
    width: 0%;
}

#audio-visualizer .audio-bar {
    height: 100%;
    background-color: #4285f4; /* Blue for output audio */
    width: 0%;
}

/* Update the animation for both visualizers */
@keyframes audio-pulse {
    0% {
        transform: scaleY(1);
    }
    50% {
        transform: scaleY(1.5);
    }
    100% {
        transform: scaleY(1);
    }
}

.audio-bar.active {
    animation: audio-pulse 0.5s infinite;
}

.settings {
    margin-bottom: 10px;
    display: flex;
    gap: 10px;
}

#api-key {
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    width: 300px;
}

#voice-select, #response-type-select{ /* Corrected selector */
    padding: 4px;
    border: 1px solid #ccc;
    border-radius: 4px;
}
 
/* Configuration panel */
#config-container {
    background: var(--surface-color);
    padding: var(--spacing-lg);
    border-radius: var(--border-radius-md); /* Use new variable */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    display: none;
}

#config-container.active {
    display: block;
}
.config-wrapper {
    display: grid;
    gap: var(--spacing-md);
    max-width: 600px;
    margin: 0 auto;
}
#apply-config {
    padding: var(--spacing-md);
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: var(--border-radius-md); /* Use new variable */
    cursor: pointer;
    transition: all 0.2s ease;
}

#apply-config:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
}

#system-instruction {
    padding: var(--spacing-md);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-md); /* Use new variable */
    font-size: 14px;
}

/* Responsive styles */
@media (max-width: 768px) {
    #app {
        padding: var(--spacing-sm);
        width: 96%;
    }

    .hidden-mobile {
        display: none;
    }

    #config-container {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1000;
        transform: translateX(100%);
        transition: transform 0.3s ease;
        overflow-y: auto;
        display: block;
        background: var(--surface-color);
        padding: var(--spacing-lg);
    }

    #config-container.active {
        transform: translateX(0);
    }

    .logs-wrapper { /* This class is not in your HTML, consider removing if unused */
        max-height: 30vh;
    }

    #logs-container {
        max-height: calc(30vh - 50px);
    }

    .input-controls {
        position: sticky;
        bottom: 0;
        background: var(--surface-color);
        padding: var(--spacing-md);
        box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.1);
        z-index: 100;
    }

    .action-buttons { /* This class is not in your HTML, consider removing if unused */
        flex-wrap: wrap;
        justify-content: center;
    }

    #video-container {
        width: 60%;
        max-height: 40vh;
        bottom: 0;
        right: 0;
    }

    #screen-container {
        width: 100%;
        height: 50vh;
        bottom: 0;
        left: 0;
        right: auto;
    }
}

.setting-container {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
}

.setting-label {
    font-size: 12px;
    font-weight: bold;
}


.fps-help {
    color: #666;
    font-size: 12px;
}```

---

### **3. `js/main.js` (ä¿æŒæ‚¨ç›®å‰æœ€æ–°çš„ã€åŒ…å«è§†é¢‘æ¸…ç†é€»è¾‘çš„ç‰ˆæœ¬)**

è¯·ç»§ç»­ä½¿ç”¨æˆ‘ä¹‹å‰æä¾›çš„ `main.js` ä»£ç ï¼Œå› ä¸ºå®ƒåŒ…å«äº†å¯¹è§†é¢‘æµè¿›è¡Œåœæ­¢å’Œæ¸…ç†çš„ JavaScript é€»è¾‘ã€‚

```javascript
import { MultimodalLiveClient } from './core/websocket-client.js';
import { AudioStreamer } => './audio/audio-streamer.js';
import { AudioRecorder } from './audio/audio-recorder.js';
import { CONFIG } from './config/config.js';
import { Logger } from './utils/logger.js';
import { VideoManager } from './video/video-manager.js';
import { ScreenRecorder } from './video/screen-recorder.js';

/**
 * @fileoverview Main entry point for the application.
 * Initializes and manages the UI, audio, video, and WebSocket interactions.
 */

// DOM Elements
const logsContainer = document.getElementById('logs-container');
const messageInput = document.getElementById('message-input');
const sendButton = document.getElementById('send-button');
const micButton = document.getElementById('mic-button');
const micIcon = document.getElementById('mic-icon');
const audioVisualizer = document.getElementById('audio-visualizer');
const connectButton = document.getElementById('connect-button');
const cameraButton = document.getElementById('camera-button');
const cameraIcon = document.getElementById('camera-icon');
const stopVideoButton = document.getElementById('stop-video');
const screenButton = document.getElementById('screen-button');
const screenIcon = document.getElementById('screen-icon');
const screenContainer = document.getElementById('screen-container');
const screenPreview = document.getElementById('screen-preview');
const inputAudioVisualizer = document.getElementById('input-audio-visualizer');
const apiKeyInput = document.getElementById('api-key');
const voiceSelect = document.getElementById('voice-select');
const fpsInput = document.getElementById('fps-input');
const configToggle = document.getElementById('config-toggle');
const configContainer = document.getElementById('config-container');
const systemInstructionInput = document.getElementById('system-instruction');
// ç¡®ä¿ç³»ç»ŸæŒ‡ä»¤è¢«ç¡¬ç¼–ç å¹¶æ˜¾ç¤º
systemInstructionInput.value = "You are my helpful assistant. You can see and hear me, and respond with voice and text. If you are asked about things you do not know, you can use the google search tool to find the answer.\nè¯·æ ¹æ®æˆ‘è¯´è¯çš„è¯­è¨€è¿›è¡Œå›å¤ã€‚å¦‚æœæˆ‘ç”¨ä¸­æ–‡è¯´è¯ï¼Œè¯·ç”¨ä¸­æ–‡å›å¤ï¼›å¦‚æœæˆ‘ç”¨è‹±æ–‡è¯´è¯ï¼Œè¯·ç”¨è‹±æ–‡å›å¤ã€‚";

const applyConfigButton = document.getElementById('apply-config');
const responseTypeSelect = document.getElementById('response-type-select');
const languageSelect = document.getElementById('language-select');

// è·å–è§†é¢‘å®¹å™¨å’Œè§†é¢‘å…ƒç´ 
const videoContainer = document.getElementById('video-container');
const preview = document.getElementById('preview');


// Load saved values from localStorage
const savedApiKey = localStorage.getItem('gemini_api_key');
const savedVoice = localStorage.getItem('gemini_voice');
const savedFPS = localStorage.getItem('video_fps');
const savedLanguage = localStorage.getItem('gemini_language');

if (savedApiKey) {
    apiKeyInput.value = savedApiKey;
}
if (savedVoice) {
    voiceSelect.value = savedVoice;
}
if (savedFPS) {
    fpsInput.value = savedFPS;
}
if (savedLanguage) {
    languageSelect.value = savedLanguage;
}


// Handle configuration panel toggle
configToggle.addEventListener('click', () => {
    configContainer.classList.toggle('active');
    configToggle.classList.toggle('active');
});

applyConfigButton.addEventListener('click', () => {
    configContainer.classList.toggle('active');
    configToggle.classList.toggle('active');
});

// State variables
let isRecording = false;
let audioStreamer = null;
let audioCtx = null;
let isConnected = false;
let audioRecorder = null;
let isVideoActive = false;
let videoManager = null;
let isScreenSharing = false;
let screenRecorder = null;
let isUsingTool = false;

// Multimodal Client
const client = new MultimodalLiveClient();

/**
 * Logs a message to the UI.
 * @param {string} message - The message to log.
 * @param {string} [type='system'] - The type of the message (system, user, ai).
 */
function logMessage(message, type = 'system') {
    const logEntry = document.createElement('div');
    logEntry.classList.add('log-entry', type);

    const timestamp = document.createElement('span');
    timestamp.classList.add('timestamp');
    timestamp.textContent = new Date().toLocaleTimeString();
    logEntry.appendChild(timestamp);

    const emoji = document.createElement('span');
    emoji.classList.add('emoji');
    switch (type) {
        case 'system':
            emoji.textContent = 'âš™ï¸';
            break;
        case 'user':
            emoji.textContent = 'ğŸ«µ';
            break;
        case 'ai':
            emoji.textContent = 'ğŸ¤–';
            break;
    }
    logEntry.appendChild(emoji);

    const messageText = document.createElement('span');
    messageText.textContent = message;
    logEntry.appendChild(messageText);

    logsContainer.appendChild(logEntry);
    logsContainer.scrollTop = logsContainer.scrollHeight;
}

/**
 * Updates the microphone icon based on the recording state.
 */
function updateMicIcon() {
    micIcon.textContent = isRecording ? 'mic_off' : 'mic';
    micButton.style.backgroundColor = isRecording ? '#ea4335' : '#4285f4';
}

/**
 * Updates the audio visualizer based on the audio volume.
 * @param {number} volume - The audio volume (0.0 to 1.0).
 * @param {boolean} [isInput=false] - Whether the visualizer is for input audio.
 */
function updateAudioVisualizer(volume, isInput = false) {
    const visualizer = isInput ? inputAudioVisualizer : audioVisualizer;
    const audioBar = visualizer.querySelector('.audio-bar') || document.createElement('div');
    
    if (!visualizer.contains(audioBar)) {
        audioBar.classList.add('audio-bar');
        visualizer.appendChild(audioBar);
    }
    
    audioBar.style.width = `${volume * 100}%`;
    if (volume > 0) {
        audioBar.classList.add('active');
    } else {
        audioBar.classList.remove('active');
    }
}

/**
 * Initializes the audio context and streamer if not already initialized.
 * @returns {Promise<AudioStreamer>} The audio streamer instance.
 */
async function ensureAudioInitialized() {
    if (!audioCtx) {
        audioCtx = new AudioContext();
    }
    if (!audioStreamer) {
        audioStreamer = new AudioStreamer(audioCtx);
        await audioStreamer.addWorklet('vumeter-out', 'js/audio/worklets/vol-meter.js', (ev) => {
            updateAudioVisualizer(ev.data.volume);
        });
    }
    return audioStreamer;
}

/**
 * Handles the microphone toggle. Starts or stops audio recording.
 * @returns {Promise<void>}
 */
async function handleMicToggle() {
    if (!isRecording) {
        try {
            await ensureAudioInitialized();
            audioRecorder = new AudioRecorder();
            
            const inputAnalyser = audioCtx.createAnalyser();
            inputAnalyser.fftSize = 256;
            const inputDataArray = new Uint8Array(inputAnalyser.frequencyBinCount);
            
            await audioRecorder.start((base64Data) => {
                if (isUsingTool) {
                    client.sendRealtimeInput([{
                        mimeType: "audio/pcm;rate=16000",
                        data: base64Data,
                        interrupt: true     // Model isn't interruptable when using tools, so we do it manually
                    }]);
                } else {
                    client.sendRealtimeInput([{
                        mimeType: "audio/pcm;rate=16000",
                        data: base64Data
                    }]);
                }
                
                inputAnalyser.getByteFrequencyData(inputDataArray);
                const inputVolume = Math.max(...inputDataArray) / 255;
                updateAudioVisualizer(inputVolume, true);
            });

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioCtx.createMediaStreamSource(stream);
            source.connect(inputAnalyser);
            
            await audioStreamer.resume();
            isRecording = true;
            Logger.info('Microphone started');
            logMessage('Microphone started', 'system');
            updateMicIcon();
        } catch (error) {
            Logger.error('Microphone error:', error);
            logMessage(`Error: ${error.message}`, 'system');
            isRecording = false;
            updateMicIcon();
        }
    } else {
        if (audioRecorder && isRecording) {
            audioRecorder.stop();
        }
        isRecording = false;
        logMessage('Microphone stopped', 'system');
        updateMicIcon();
        updateAudioVisualizer(0, true);
    }
}

/**
 * Resumes the audio context if it's suspended.
 * @returns {Promise<void>}
 */
async function resumeAudioContext() {
    if (audioCtx && audioCtx.state === 'suspended') {
        await audioCtx.resume();
    }
}

/**
 * Connects to the WebSocket server.
 * @returns {Promise<void>}
 */
async function connectToWebsocket() {
    if (!apiKeyInput.value) {
        logMessage('Please input API Key', 'system');
        return;
    }

    // Save values to localStorage
    localStorage.setItem('gemini_api_key', apiKeyInput.value);
    localStorage.setItem('gemini_voice', voiceSelect.value);
    localStorage.setItem('gemini_language', languageSelect.value);

    const config = {
        model: CONFIG.API.MODEL_NAME,
        generationConfig: {
            responseModalities: responseTypeSelect.value,
            speechConfig: {
				languageCode: languageSelect.value,
                voiceConfig: { 
                    prebuiltVoiceConfig: { 
                        voiceName: voiceSelect.value
                    }
                }
            },

        },
        systemInstruction: {
            parts: [{
                // ç¡¬ç¼–ç ç³»ç»ŸæŒ‡ä»¤åœ¨è¿™é‡Œï¼Œç¡®ä¿å®ƒå§‹ç»ˆè¢«å‘é€ç»™ API
                text: "You are my helpful assistant. You can see and hear me, and respond with voice and text. If you are asked about things you do not know, you can use the google search tool to find the answer.\nè¯·æ ¹æ®æˆ‘è¯´è¯çš„è¯­è¨€è¿›è¡Œå›å¤ã€‚å¦‚æœæˆ‘ç”¨ä¸­æ–‡è¯´è¯ï¼Œè¯·ç”¨ä¸­æ–‡å›å¤ï¼›å¦‚æœæˆ‘ç”¨è‹±æ–‡è¯´è¯ï¼Œè¯·ç”¨è‹±æ–‡å›å¤ã€‚"
            }],
        }
    };  

    try {
        await client.connect(config,apiKeyInput.value);
        isConnected = true;
        await resumeAudioContext();
        connectButton.textContent = 'Disconnect';
        connectButton.classList.add('connected');
        messageInput.disabled = false;
        sendButton.disabled = false;
        micButton.disabled = false;
        cameraButton.disabled = false;
        screenButton.disabled = false;
        logMessage('Connected to Gemini 2.0 Flash Multimodal Live API', 'system');
    } catch (error) {
        const errorMessage = error.message || 'Unknown error';
        Logger.error('Connection error:', error);
        logMessage(`Connection error: ${errorMessage}`, 'system');
        isConnected = false;
        connectButton.textContent = 'Connect';
        connectButton.classList.remove('connected');
        messageInput.disabled = true;
        sendButton.disabled = true;
        micButton.disabled = true;
        cameraButton.disabled = true;
        screenButton.disabled = true;
    }
}

/**
 * Disconnects from the WebSocket server.
 */
function disconnectFromWebsocket() {
    client.disconnect();
    isConnected = false;
    if (audioStreamer) {
        audioStreamer.stop();
        if (audioRecorder) {
            audioRecorder.stop();
            audioRecorder = null;
        }
        isRecording = false;
        updateMicIcon();
    }
    connectButton.textContent = 'Connect';
    connectButton.classList.remove('connected');
    messageInput.disabled = true;
    sendButton.disabled = true;
    micButton.disabled = true;
    cameraButton.disabled = true;
    screenButton.disabled = true;
    logMessage('Disconnected from server', 'system');
    
    // ç¡®ä¿åœ¨æ–­å¼€è¿æ¥æ—¶åœæ­¢å¹¶æ¸…é™¤è§†é¢‘/å±å¹•å…±äº«
    if (videoManager) {
        stopVideo();
    }
    
    if (screenRecorder) {
        stopScreenSharing();
    }
}

/**
 * Handles sending a text message.
 */
function handleSendMessage() {
    const message = messageInput.value.trim();
    if (message) {
        logMessage(message, 'user');
        client.send({ text: message });
        messageInput.value = '';
    }
}

// Event Listeners
client.on('open', () => {
    logMessage('WebSocket connection opened', 'system');
});

client.on('log', (log) => {
    logMessage(`${log.type}: ${JSON.stringify(log.message)}`, 'system');
});

client.on('close', (event) => {
    logMessage(`WebSocket connection closed (code ${event.code})`, 'system');
});

client.on('audio', async (data) => {
    try {
        await resumeAudioContext();
        const streamer = await ensureAudioInitialized();
        streamer.addPCM16(new Uint8Array(data));
    } catch (error) {
        logMessage(`Error processing audio: ${error.message}`, 'system');
    }
});

client.on('content', (data) => {
    if (data.modelTurn) {
        if (data.modelTurn.parts.some(part => part.functionCall)) {
            isUsingTool = true;
            Logger.info('Model is using a tool');
        } else if (data.modelTurn.parts.some(part => part.functionResponse)) {
            isUsingTool = false;
            Logger.info('Tool usage completed');
        }

        const text = data.modelTurn.parts.map(part => part.text).join('');
        if (text) {
            logMessage(text, 'ai');
        }
    }
});

client.on('interrupted', () => {
    audioStreamer?.stop();
    isUsingTool = false;
    Logger.info('Model interrupted');
    logMessage('Model interrupted', 'system');
});

client.on('setupcomplete', () => {
    logMessage('Setup complete', 'system');
});

client.on('turncomplete', () => {
    isUsingTool = false;
    logMessage('Turn complete', 'system');
});

client.on('error', (error) => {
    if (error instanceof ApplicationError) {
        Logger.error(`Application error: ${error.message}`, error);
    } else {
        Logger.error('Unexpected error', error);
    }
    logMessage(`Error: ${error.message}`, 'system');
});

client.on('message', (message) => {
    if (message.error) {
        Logger.error('Server error:', message.error);
        logMessage(`Server error: ${message.error}`, 'system');
    }
});

sendButton.addEventListener('click', handleSendMessage);
messageInput.addEventListener('keypress', (event) => {
    if (event.key === 'Enter') {
        handleSendMessage();
    }
});

micButton.addEventListener('click', handleMicToggle);

connectButton.addEventListener('click', () => {
    if (isConnected) {
        disconnectFromWebsocket();
    } else {
        connectToWebsocket();
    }
});

messageInput.disabled = true;
sendButton.disabled = true;
micButton.disabled = true;
connectButton.textContent = 'Connect';

/**
 * Handles the video toggle. Starts or stops video streaming.
 * @returns {Promise<void>}
 */
async function handleVideoToggle() {
    Logger.info('Video toggle clicked, current state:', { isVideoActive, isConnected });
    
    localStorage.setItem('video_fps', fpsInput.value);

    if (!isVideoActive) {
        try {
            Logger.info('Attempting to start video');
            if (!videoManager) {
                videoManager = new VideoManager();
            }
            
            // videoManager.start å†…éƒ¨åº”è¯¥ä¼šè®¾ç½® preview.srcObject
            await videoManager.start(fpsInput.value,(frameData) => {
                if (isConnected) {
                    client.sendRealtimeInput([frameData]);
                }
            });

            // ç¡®ä¿è§†é¢‘å®¹å™¨æ˜¾ç¤º
            videoContainer.style.display = 'block';

            isVideoActive = true;
            cameraIcon.textContent = 'videocam_off';
            cameraButton.classList.add('active');
            Logger.info('Camera started successfully');
            logMessage('Camera started', 'system');

        } catch (error) {
            Logger.error('Camera error:', error);
            logMessage(`Error: ${error.message}`, 'system');
            isVideoActive = false;
            videoManager = null;
            cameraIcon.textContent = 'videocam';
            cameraButton.classList.remove('active');
            // å‘ç”Ÿé”™è¯¯æ—¶ä¹Ÿæ‰§è¡Œå®Œæ•´çš„åœæ­¢é€»è¾‘ï¼Œç¡®ä¿æ¸…é™¤æ®‹ç•™
            stopVideo(); 
        }
    } else {
        Logger.info('Stopping video');
        stopVideo();
    }
}

/**
 * Stops the video streaming.
 */
function stopVideo() {
    Logger.info('Attempting to stop video and clear display.');
    if (preview) {
        preview.pause(); // æš‚åœè§†é¢‘æ’­æ”¾
        Logger.info('Video element paused.');

        if (preview.srcObject) {
            // è·å–å¹¶åœæ­¢æ‰€æœ‰ MediaStreamTrack
            const tracks = preview.srcObject.getTracks();
            tracks.forEach(track => {
                track.stop(); // åœæ­¢è½¨é“
                Logger.info(`Track stopped: ${track.kind} - ${track.label}`);
            });
            preview.srcObject = null; // æ¸…é™¤ srcObject
            Logger.info('srcObject set to null.');
        } else {
            Logger.info('No active srcObject found on preview element.');
        }
        
        // **å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶è§†é¢‘å…ƒç´ é‡ç½®ä»¥æ¸…é™¤æ®‹ç•™ç”»é¢**
        // 1. è®¾ç½®ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ä½œä¸º src
        preview.src = ''; 
        // 2. å¼ºåˆ¶åŠ è½½è¿™ä¸ªç©º srcï¼Œè¿™ä¼šæ¸…ç©ºå†…éƒ¨ç¼“å†²åŒº
        preview.load();   
        Logger.info('Video element src set to empty and loaded for clearing.');

    } else {
        Logger.info('Preview element not found.');
    }

    if (videoManager) {
        videoManager.stop(); // è°ƒç”¨ videoManager çš„ stop æ–¹æ³• (å¯èƒ½é‡å¤ä½†å®‰å…¨)
        videoManager = null;
        Logger.info('VideoManager stopped.');
    }
    
    // éšè—å®¹å™¨
    videoContainer.style.display = 'none';
    Logger.info('Video container hidden.');

    isVideoActive = false;
    cameraIcon.textContent = 'videocam';
    cameraButton.classList.remove('active');
    logMessage('Camera stopped', 'system');
}

cameraButton.addEventListener('click', handleVideoToggle);
stopVideoButton.addEventListener('click', stopVideo);

cameraButton.disabled = true;

/**
 * Handles the screen share toggle. Starts or stops screen sharing.
 * @returns {Promise<void>}
 */
async function handleScreenShare() {
    if (!isScreenSharing) {
        try {
            screenContainer.style.display = 'block';
            
            screenRecorder = new ScreenRecorder();
            // screenRecorder.start å†…éƒ¨åº”è¯¥ä¼šè®¾ç½® screenPreview.srcObject
            await screenRecorder.start(screenPreview, (frameData) => {
                if (isConnected) {
                    client.sendRealtimeInput([{
                        mimeType: "image/jpeg",
                        data: frameData
                    }]);
                }
            });

            isScreenSharing = true;
            screenIcon.textContent = 'stop_screen_share';
            screenButton.classList.add('active');
            Logger.info('Screen sharing started');
            logMessage('Screen sharing started', 'system');

        } catch (error) {
            Logger.error('Screen sharing error:', error);
            logMessage(`Error: ${error.message}`, 'system');
            isScreenSharing = false;
            screenIcon.textContent = 'screen_share';
            screenButton.classList.remove('active');
            // å‘ç”Ÿé”™è¯¯æ—¶ä¹Ÿæ‰§è¡Œå®Œæ•´çš„åœæ­¢é€»è¾‘ï¼Œç¡®ä¿æ¸…é™¤æ®‹ç•™
            stopScreenSharing();
        }
    } else {
        stopScreenSharing();
    }
}

/**
 * Stops the screen sharing.
 */
function stopScreenSharing() {
    Logger.info('Attempting to stop screen sharing and clear display.');
    if (screenPreview) {
        screenPreview.pause(); // æš‚åœè§†é¢‘æ’­æ”¾
        Logger.info('Screen preview element paused.');

        if (screenPreview.srcObject) {
            // è·å–å¹¶åœæ­¢æ‰€æœ‰ MediaStreamTrack
            const tracks = screenPreview.srcObject.getTracks();
            tracks.forEach(track => {
                track.stop(); // åœæ­¢è½¨é“
                Logger.info(`Screen track stopped: ${track.kind} - ${track.label}`);
            });
            screenPreview.srcObject = null; // æ¸…é™¤ srcObject
            Logger.info('Screen srcObject set to null.');
        } else {
            Logger.info('No active srcObject found on screenPreview element.');
        }
        
        // **å…³é”®ä¿®å¤ï¼šå¼ºåˆ¶è§†é¢‘å…ƒç´ é‡ç½®ä»¥æ¸…é™¤æ®‹ç•™ç”»é¢**
        // 1. è®¾ç½®ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ä½œä¸º src
        screenPreview.src = ''; 
        // 2. å¼ºåˆ¶åŠ è½½è¿™ä¸ªç©º srcï¼Œè¿™ä¼šæ¸…ç©ºå†…éƒ¨ç¼“å†²åŒº
        screenPreview.load();   
        Logger.info('Screen preview element src set to empty and loaded for clearing.');

    } else {
        Logger.info('Screen preview element not found.');
    }

    if (screenRecorder) {
        screenRecorder.stop(); // è°ƒç”¨ screenRecorder çš„ stop æ–¹æ³•
        screenRecorder = null;
        Logger.info('ScreenRecorder stopped.');
    }
    
    screenContainer.style.display = 'none';
    Logger.info('Screen container hidden.');

    isScreenSharing = false;
    screenIcon.textContent = 'screen_share';
    screenButton.classList.remove('active');
    logMessage('Screen sharing stopped', 'system');
}

screenButton.addEventListener('click', handleScreenShare);
screenButton.disabled = true;
